# -*- coding: utf-8 -*-
"""
Created on Sat Sep 14 22:47:13 2019

@author: Abdullah
Detect Lanes and draw Lines using OpenCV
This program draws lane lines in a car driving path image 
Same should work on a live video generated by a self-driving car
"""
import cv2
import numpy as np

# Read the image
image = cv2.imread("carDriveImage.png")
cv2.imshow("Image", image)
cv2.waitKey(0)

# Convert it to gray and reduce noise by Gaussian Blur
lane_image = np.copy(image)
grayed = cv2.cvtColor(lane_image, cv2.COLOR_RGB2GRAY)
blurred = cv2.GaussianBlur(grayed, (5, 5), 0)
cv2.imshow("Blurred", blurred)
cv2.waitKey(0)

# Detect edges by Canny algorithm
edges = cv2.Canny(blurred, 50, 150)
cv2.imshow("Edges", edges)
cv2.waitKey(0)

# Create region of interest mask 
height = edges.shape[0]
triangle = np.array([[(200,  height), (1100, height), (550, 250)]])
mask = np.zeros_like(edges)
cv2.fillPoly(mask, triangle, 255)
cv2.imshow("Mask", mask)
cv2.waitKey(0)

# Crop region of interest by masking edges with the above mask
masked_image = cv2.bitwise_and(edges, mask)
cv2.imshow("Masked Edges", masked_image)
cv2.waitKey(0)

# Detect Lane Lines by Hough Transform
lines = cv2.HoughLinesP(masked_image, 2, np.pi/180, 100, np.array([]), minLineLength=40, maxLineGap=5)
lines=lines[0]

# Create lines images using detected params
def create_line_image(image, lines):
    line_image = np.zeros_like(image)
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line
            cv2.line(line_image, (x1, y1), (x2, y2), (255, 0, 0), 10)
    return(line_image)
    
line_image = create_line_image(lane_image, lines)
cv2.imshow("Line Image", line_image)
cv2.waitKey(0)
combo_image = cv2.addWeighted(lane_image, 0.8, line_image, 1, 1)
cv2.imshow("Combined Image", combo_image)
cv2.waitKey(0)

# Find the line coordinates for line image params
def create_coordinates(image, line_params):
    slope, intercept = line_params
    y1 = image.shape[0]
    print(y1)
    y2 = int(y1*2.9/5)
    print(y2)
    x1 = int((y1 - intercept)/slope)
    x2 = int((y2 - intercept)/slope)
    return np.array([x1, y1, x2, y2])

# Create a single averaged line from multiple lines
left_fit = []
right_fit = []

for line in lines:
    x1, y1, x2, y2 = line
    retval = np.polyfit((x1, x2), (y1, y2), 1)
    slope = retval[0]
    intercept = retval[1]
    if slope < 0:
        left_fit.append((slope, intercept))
    else:    
        right_fit.append((slope, intercept))
left_fit_average = np.average(left_fit, axis=0)
right_fit_average = np.average(right_fit, axis=0)
left_line = create_coordinates(image, left_fit_average)
right_line = create_coordinates(image, right_fit_average)

averaged_lines = np.array([left_line, right_line])

line_image = create_line_image(lane_image, averaged_lines)
cv2.imshow("Line Image", line_image)
cv2.waitKey(0)

# Display final detected lane lines on the actual image
combo_image = cv2.addWeighted(lane_image, 0.8, line_image, 1, 1)
cv2.imshow("Final Image with Detected Lane Lines", combo_image)
cv2.waitKey(0)

cv2.destroyAllWindows()
